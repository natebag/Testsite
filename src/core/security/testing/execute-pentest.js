#!/usr/bin/env node

/**
 * MLG.clan Security Penetration Testing Execution Script
 * Command-line interface for running comprehensive security tests
 * 
 * @author Claude Code - Universal Testing & Verification Agent
 * @version 1.0.0
 * @created 2025-08-13
 */

import { SecurityTestSuite, SECURITY_TEST_CONFIG } from './security-test-suite.js';
import fs from 'fs/promises';
import path from 'path';

/**
 * CLI Configuration
 */
const CLI_CONFIG = {
  REPORT_FORMATS: {
    JSON: 'json',
    HTML: 'html',
    MARKDOWN: 'md',
    PDF: 'pdf'
  },
  
  OUTPUT_DIRECTORY: process.env.PENTEST_OUTPUT_DIR || './security-reports',
  
  COMMAND_OPTIONS: {
    mode: {
      alias: 'm',
      description: 'Test execution mode (quick|standard|thorough|compliance)',
      default: 'standard'
    },
    output: {
      alias: 'o',
      description: 'Output directory for reports',
      default: './security-reports'
    },
    format: {
      alias: 'f',
      description: 'Report format (json|html|md)',
      default: 'json'
    },
    target: {
      alias: 't',
      description: 'Target URL for testing',
      default: 'http://localhost:3000'
    },
    verbose: {
      alias: 'v',
      description: 'Verbose output',
      type: 'boolean',
      default: false
    },
    categories: {
      alias: 'c',
      description: 'Test categories to run (comma-separated)',
      default: 'all'
    }
  }
};

/**
 * Main CLI Class
 */
class SecurityPentestCLI {
  constructor() {
    this.args = this.parseArguments();
    this.testSuite = null;
    this.outputDirectory = this.args.output;
  }

  /**
   * Parse command line arguments
   */
  parseArguments() {
    const args = process.argv.slice(2);
    const parsedArgs = {
      mode: 'standard',
      output: './security-reports',
      format: 'json',
      target: 'http://localhost:3000',
      verbose: false,
      categories: 'all'
    };

    for (let i = 0; i < args.length; i += 2) {
      const arg = args[i];
      const value = args[i + 1];

      switch (arg) {
        case '--mode':
        case '-m':
          parsedArgs.mode = value;
          break;
        case '--output':
        case '-o':
          parsedArgs.output = value;
          break;
        case '--format':
        case '-f':
          parsedArgs.format = value;
          break;
        case '--target':
        case '-t':
          parsedArgs.target = value;
          break;
        case '--categories':
        case '-c':
          parsedArgs.categories = value;
          break;
        case '--verbose':
        case '-v':
          parsedArgs.verbose = true;
          i--; // No value for boolean flag
          break;
        case '--help':
        case '-h':
          this.showHelp();
          process.exit(0);
          break;
      }
    }

    return parsedArgs;
  }

  /**
   * Show help information
   */
  showHelp() {
    console.log(`
üîí MLG.clan Security Penetration Testing Suite

USAGE:
  node execute-pentest.js [OPTIONS]

OPTIONS:
  -m, --mode <mode>         Test execution mode
                           ‚Ä¢ quick     - Essential tests (~5 min)
                           ‚Ä¢ standard  - Comprehensive tests (~15 min)
                           ‚Ä¢ thorough  - All tests (~30 min)
                           ‚Ä¢ compliance - Compliance tests (~20 min)

  -t, --target <url>        Target URL for testing
                           Default: http://localhost:3000

  -o, --output <dir>        Output directory for reports
                           Default: ./security-reports

  -f, --format <format>     Report format
                           ‚Ä¢ json      - JSON format
                           ‚Ä¢ html      - HTML report
                           ‚Ä¢ md        - Markdown format

  -c, --categories <cats>   Test categories (comma-separated)
                           ‚Ä¢ auth      - Authentication tests
                           ‚Ä¢ api       - API security tests
                           ‚Ä¢ web3      - Web3 security tests
                           ‚Ä¢ gaming    - Gaming-specific tests
                           ‚Ä¢ ddos      - DDoS protection tests
                           ‚Ä¢ all       - All categories (default)

  -v, --verbose            Verbose output
  -h, --help               Show this help

EXAMPLES:
  # Quick security scan
  node execute-pentest.js --mode quick --target https://mlg.clan

  # Comprehensive test with HTML report
  node execute-pentest.js --mode thorough --format html --output ./reports

  # Test specific categories
  node execute-pentest.js --categories auth,api,web3 --verbose

  # Compliance testing
  node execute-pentest.js --mode compliance --format md

ENVIRONMENT VARIABLES:
  TEST_BASE_URL           Base URL for testing (default: http://localhost:3000)
  TEST_API_URL           API URL for testing (default: http://localhost:3000/api)
  TEST_WEB3_NETWORK      Web3 network (default: devnet)
  PENTEST_OUTPUT_DIR     Default output directory
    `);
  }

  /**
   * Execute penetration testing
   */
  async execute() {
    try {
      console.log('üîí MLG.clan Security Penetration Testing Suite');
      console.log('=' .repeat(50));
      console.log(`Mode: ${this.args.mode.toUpperCase()}`);
      console.log(`Target: ${this.args.target}`);
      console.log(`Output: ${this.args.output}`);
      console.log(`Format: ${this.args.format.toUpperCase()}`);
      console.log('=' .repeat(50));

      // Validate arguments
      await this.validateArguments();

      // Create output directory
      await this.createOutputDirectory();

      // Initialize test suite
      await this.initializeTestSuite();

      // Execute security tests
      const results = await this.runSecurityTests();

      // Generate and save reports
      await this.generateReports(results);

      // Display summary
      this.displaySummary(results);

      // Return appropriate exit code
      process.exit(this.getExitCode(results));

    } catch (error) {
      console.error('‚ùå Penetration testing failed:', error.message);
      
      if (this.args.verbose) {
        console.error('Stack trace:', error.stack);
      }
      
      process.exit(1);
    }
  }

  /**
   * Validate command line arguments
   */
  async validateArguments() {
    // Validate execution mode
    const validModes = Object.values(SECURITY_TEST_CONFIG.EXECUTION_MODES);
    if (!validModes.includes(this.args.mode)) {
      throw new Error(`Invalid mode: ${this.args.mode}. Valid modes: ${validModes.join(', ')}`);
    }

    // Validate report format
    const validFormats = Object.values(CLI_CONFIG.REPORT_FORMATS);
    if (!validFormats.includes(this.args.format)) {
      throw new Error(`Invalid format: ${this.args.format}. Valid formats: ${validFormats.join(', ')}`);
    }

    // Validate target URL
    try {
      new URL(this.args.target);
    } catch (error) {
      throw new Error(`Invalid target URL: ${this.args.target}`);
    }

    // Test target connectivity
    if (this.args.verbose) {
      console.log('üîç Testing target connectivity...');
      await this.testConnectivity();
    }
  }

  /**
   * Test target connectivity
   */
  async testConnectivity() {
    try {
      const fetch = (await import('node-fetch')).default;
      const response = await fetch(this.args.target, { 
        timeout: 10000,
        signal: AbortSignal.timeout(10000)
      });
      
      if (this.args.verbose) {
        console.log(`‚úÖ Target accessible: ${response.status} ${response.statusText}`);
      }
    } catch (error) {
      console.warn(`‚ö†Ô∏è Target connectivity issue: ${error.message}`);
      console.warn('   Continuing with tests - some may fail');
    }
  }

  /**
   * Create output directory
   */
  async createOutputDirectory() {
    try {
      await fs.mkdir(this.outputDirectory, { recursive: true });
      
      if (this.args.verbose) {
        console.log(`üìÅ Output directory created: ${this.outputDirectory}`);
      }
    } catch (error) {
      throw new Error(`Failed to create output directory: ${error.message}`);
    }
  }

  /**
   * Initialize test suite
   */
  async initializeTestSuite() {
    if (this.args.verbose) {
      console.log('üöÄ Initializing security test suite...');
    }

    this.testSuite = new SecurityTestSuite({
      mode: this.args.mode,
      TEST_ENVIRONMENT: {
        BASE_URL: this.args.target,
        API_BASE_URL: `${this.args.target}/api`,
        WEB3_NETWORK: process.env.TEST_WEB3_NETWORK || 'devnet'
      }
    });

    await this.testSuite.initialize();

    if (this.args.verbose) {
      console.log('‚úÖ Test suite initialized successfully');
    }
  }

  /**
   * Run security tests
   */
  async runSecurityTests() {
    console.log(`üîç Starting ${this.args.mode} security testing...`);
    console.log('');

    // Setup progress monitoring if verbose
    if (this.args.verbose) {
      this.setupProgressMonitoring();
    }

    const startTime = Date.now();
    const results = await this.testSuite.executeSuite(this.args.mode);
    const endTime = Date.now();

    results.executionTime = endTime - startTime;

    console.log('');
    console.log(`‚úÖ Security testing completed in ${(results.executionTime / 1000).toFixed(2)}s`);

    return results;
  }

  /**
   * Setup progress monitoring
   */
  setupProgressMonitoring() {
    // This would implement real-time progress updates
    // For now, just log that monitoring is enabled
    console.log('üìä Progress monitoring enabled');
  }

  /**
   * Generate and save reports
   */
  async generateReports(results) {
    console.log('üìù Generating security reports...');

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const baseFilename = `security-report-${this.args.mode}-${timestamp}`;

    // Generate reports in requested format
    switch (this.args.format) {
      case 'json':
        await this.generateJSONReport(results, baseFilename);
        break;
      case 'html':
        await this.generateHTMLReport(results, baseFilename);
        break;
      case 'md':
        await this.generateMarkdownReport(results, baseFilename);
        break;
    }

    // Always generate a summary JSON for programmatic access
    if (this.args.format !== 'json') {
      await this.generateJSONSummary(results, `${baseFilename}-summary`);
    }
  }

  /**
   * Generate JSON report
   */
  async generateJSONReport(results, filename) {
    const reportPath = path.join(this.outputDirectory, `${filename}.json`);
    
    try {
      await fs.writeFile(reportPath, JSON.stringify(results, null, 2));
      console.log(`üìÑ JSON report saved: ${reportPath}`);
    } catch (error) {
      console.error(`‚ùå Failed to save JSON report: ${error.message}`);
    }
  }

  /**
   * Generate HTML report
   */
  async generateHTMLReport(results, filename) {
    const reportPath = path.join(this.outputDirectory, `${filename}.html`);
    
    try {
      const htmlContent = this.generateHTMLContent(results);
      await fs.writeFile(reportPath, htmlContent);
      console.log(`üìÑ HTML report saved: ${reportPath}`);
    } catch (error) {
      console.error(`‚ùå Failed to save HTML report: ${error.message}`);
    }
  }

  /**
   * Generate Markdown report
   */
  async generateMarkdownReport(results, filename) {
    const reportPath = path.join(this.outputDirectory, `${filename}.md`);
    
    try {
      const markdownContent = this.generateMarkdownContent(results);
      await fs.writeFile(reportPath, markdownContent);
      console.log(`üìÑ Markdown report saved: ${reportPath}`);
    } catch (error) {
      console.error(`‚ùå Failed to save Markdown report: ${error.message}`);
    }
  }

  /**
   * Generate JSON summary
   */
  async generateJSONSummary(results, filename) {
    const summaryPath = path.join(this.outputDirectory, `${filename}.json`);
    
    const summary = {
      executionMode: results.mode,
      duration: results.duration,
      securityPosture: results.report?.executiveSummary?.securityPosture,
      riskScore: results.report?.executiveSummary?.riskScore,
      vulnerabilities: results.report?.executiveSummary?.vulnerabilitiesFound,
      recommendation: results.recommendation
    };
    
    try {
      await fs.writeFile(summaryPath, JSON.stringify(summary, null, 2));
      
      if (this.args.verbose) {
        console.log(`üìÑ Summary saved: ${summaryPath}`);
      }
    } catch (error) {
      console.error(`‚ùå Failed to save summary: ${error.message}`);
    }
  }

  /**
   * Generate HTML content
   */
  generateHTMLContent(results) {
    const report = results.report;
    const summary = report.executiveSummary;
    
    return `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MLG.clan Security Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; line-height: 1.6; }
        .header { background: #f4f4f4; padding: 20px; border-left: 5px solid #333; }
        .summary { background: #e8f5e8; padding: 15px; margin: 20px 0; border-radius: 5px; }
        .critical { color: #d32f2f; font-weight: bold; }
        .high { color: #f57c00; font-weight: bold; }
        .medium { color: #fbc02d; font-weight: bold; }
        .low { color: #388e3c; }
        .secure { color: #4caf50; font-weight: bold; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        .recommendation { background: #fff3cd; padding: 15px; border-radius: 5px; margin: 20px 0; }
    </style>
</head>
<body>
    <div class="header">
        <h1>üîí MLG.clan Security Penetration Testing Report</h1>
        <p><strong>Generated:</strong> ${report.metadata.generatedAt}</p>
        <p><strong>Mode:</strong> ${results.mode.toUpperCase()}</p>
        <p><strong>Duration:</strong> ${(results.duration / 1000).toFixed(2)}s</p>
    </div>

    <div class="summary">
        <h2>Executive Summary</h2>
        <p><strong>Security Posture:</strong> <span class="${summary.securityPosture.toLowerCase()}">${summary.securityPosture}</span></p>
        <p><strong>Risk Score:</strong> ${summary.riskScore}/100</p>
        <p><strong>Tests Executed:</strong> ${summary.totalTests}</p>
        <p><strong>Vulnerabilities Found:</strong> ${summary.vulnerabilitiesFound}</p>
        <p><strong>Test Success Rate:</strong> ${((summary.passedTests / summary.totalTests) * 100).toFixed(1)}%</p>
    </div>

    <div class="recommendation">
        <h3>Recommendation</h3>
        <p>${results.recommendation.reason}</p>
        <p><strong>Decision:</strong> ${results.recommendation.decision}</p>
        <p><strong>Timeline:</strong> ${results.recommendation.timeline}</p>
    </div>

    <h2>Vulnerability Analysis</h2>
    <table>
        <tr>
            <th>Severity</th>
            <th>Count</th>
            <th>Description</th>
        </tr>
        <tr>
            <td class="critical">Critical</td>
            <td>${report.vulnerabilityAnalysis.critical}</td>
            <td>Immediate security threats requiring urgent attention</td>
        </tr>
        <tr>
            <td class="high">High</td>
            <td>${report.vulnerabilityAnalysis.high}</td>
            <td>Significant security risks that should be addressed quickly</td>
        </tr>
        <tr>
            <td class="medium">Medium</td>
            <td>${report.vulnerabilityAnalysis.medium}</td>
            <td>Moderate security concerns requiring attention</td>
        </tr>
        <tr>
            <td class="low">Low</td>
            <td>${report.vulnerabilityAnalysis.low}</td>
            <td>Minor security issues or best practice violations</td>
        </tr>
    </table>

    <h2>Compliance Assessment</h2>
    <ul>
        <li><strong>OWASP Top 10:</strong> ${report.complianceAssessment.owasp.status} (${report.complianceAssessment.owasp.coverage}% coverage)</li>
        <li><strong>GDPR:</strong> ${report.complianceAssessment.gdpr.status} (${report.complianceAssessment.gdpr.coverage}% coverage)</li>
        <li><strong>Gaming Security:</strong> ${report.complianceAssessment.gaming.status} (${report.complianceAssessment.gaming.coverage}% coverage)</li>
        <li><strong>Web3 Security:</strong> ${report.complianceAssessment.web3.status} (${report.complianceAssessment.web3.coverage}% coverage)</li>
    </ul>

    <h2>Immediate Actions Required</h2>
    <ul>
        ${report.recommendations.immediate.map(action => `<li>${action}</li>`).join('')}
    </ul>

    <footer style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #ccc; font-size: 12px; color: #666;">
        <p>Generated by MLG.clan Security Test Suite v1.0.0</p>
        <p>Universal Testing & Verification Agent - Claude Code</p>
    </footer>
</body>
</html>`;
  }

  /**
   * Generate Markdown content
   */
  generateMarkdownContent(results) {
    const report = results.report;
    const summary = report.executiveSummary;
    
    return `# üîí MLG.clan Security Penetration Testing Report

**Generated:** ${report.metadata.generatedAt}  
**Mode:** ${results.mode.toUpperCase()}  
**Duration:** ${(results.duration / 1000).toFixed(2)}s  
**Framework:** ${report.metadata.framework}

## Executive Summary

- **Security Posture:** ${summary.securityPosture}
- **Risk Score:** ${summary.riskScore}/100
- **Tests Executed:** ${summary.totalTests}
- **Vulnerabilities Found:** ${summary.vulnerabilitiesFound}
- **Test Success Rate:** ${((summary.passedTests / summary.totalTests) * 100).toFixed(1)}%

### Recommendation

**${results.recommendation.decision}**

${results.recommendation.reason}

**Timeline:** ${results.recommendation.timeline}

## Vulnerability Analysis

| Severity | Count | Description |
|----------|-------|-------------|
| Critical | ${report.vulnerabilityAnalysis.critical} | Immediate security threats requiring urgent attention |
| High     | ${report.vulnerabilityAnalysis.high} | Significant security risks that should be addressed quickly |
| Medium   | ${report.vulnerabilityAnalysis.medium} | Moderate security concerns requiring attention |
| Low      | ${report.vulnerabilityAnalysis.low} | Minor security issues or best practice violations |

## Compliance Assessment

- **OWASP Top 10:** ${report.complianceAssessment.owasp.status} (${report.complianceAssessment.owasp.coverage}% coverage)
- **GDPR:** ${report.complianceAssessment.gdpr.status} (${report.complianceAssessment.gdpr.coverage}% coverage)
- **Gaming Security:** ${report.complianceAssessment.gaming.status} (${report.complianceAssessment.gaming.coverage}% coverage)
- **Web3 Security:** ${report.complianceAssessment.web3.status} (${report.complianceAssessment.web3.coverage}% coverage)

## Immediate Actions Required

${report.recommendations.immediate.map(action => `- ${action}`).join('\n')}

## Short-term Actions (1-3 months)

${report.recommendations.shortTerm.map(action => `- ${action}`).join('\n')}

## Long-term Actions (3-12 months)

${report.recommendations.longTerm.map(action => `- ${action}`).join('\n')}

---

*Generated by MLG.clan Security Test Suite v1.0.0*  
*Universal Testing & Verification Agent - Claude Code*
`;
  }

  /**
   * Display execution summary
   */
  displaySummary(results) {
    console.log('');
    console.log('üîí SECURITY TESTING SUMMARY');
    console.log('=' .repeat(50));
    console.log(`Mode: ${results.mode.toUpperCase()}`);
    console.log(`Duration: ${(results.duration / 1000).toFixed(2)}s`);
    console.log(`Tests Executed: ${results.metrics.totalTests}`);
    console.log(`Tests Passed: ${results.metrics.passedTests}`);
    console.log(`Tests Failed: ${results.metrics.failedTests}`);
    console.log(`Vulnerabilities: ${results.metrics.vulnerabilities.length}`);
    
    if (results.report) {
      const summary = results.report.executiveSummary;
      console.log(`Security Posture: ${summary.securityPosture}`);
      console.log(`Risk Score: ${summary.riskScore}/100`);
    }
    
    console.log('');
    console.log(`üìù Reports saved to: ${this.outputDirectory}`);
    console.log('');
    console.log('üéØ RECOMMENDATION:');
    console.log(`${results.recommendation.decision}: ${results.recommendation.reason}`);
    console.log(`Timeline: ${results.recommendation.timeline}`);
    console.log('=' .repeat(50));
  }

  /**
   * Get exit code based on results
   */
  getExitCode(results) {
    if (!results.success) {
      return 1; // Execution failed
    }
    
    if (results.report) {
      const posture = results.report.executiveSummary.securityPosture;
      
      switch (posture) {
        case 'CRITICAL':
          return 2; // Critical vulnerabilities
        case 'HIGH_RISK':
          return 3; // High risk vulnerabilities
        case 'MEDIUM_RISK':
          return 4; // Medium risk vulnerabilities
        case 'LOW_RISK':
          return 5; // Low risk vulnerabilities
        case 'SECURE':
          return 0; // All secure
        default:
          return 6; // Unknown status
      }
    }
    
    return 0; // Success
  }

  /**
   * Cleanup resources
   */
  async cleanup() {
    if (this.testSuite) {
      await this.testSuite.cleanup();
    }
  }
}

/**
 * Main execution function
 */
async function main() {
  const cli = new SecurityPentestCLI();
  
  // Handle process signals for graceful shutdown
  process.on('SIGINT', async () => {
    console.log('\n‚èπÔ∏è Received interrupt signal, cleaning up...');
    await cli.cleanup();
    process.exit(130);
  });

  process.on('SIGTERM', async () => {
    console.log('\n‚èπÔ∏è Received termination signal, cleaning up...');
    await cli.cleanup();
    process.exit(143);
  });

  // Execute penetration testing
  await cli.execute();
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch(error => {
    console.error('‚ùå Unhandled error:', error);
    process.exit(1);
  });
}

export default SecurityPentestCLI;